[{"title":"一张图理解JS中的原型和原型链","date":"2019-08-26T11:19:11.000Z","path":"2019/08/26/一张图理解JS中的原型和原型链/","text":"前言 面试必问的原型和原型链问题,先来开具一张图，后面就全靠想了 1.构造函数 从上面的图片开始分析，我们先定义一个构造函数，并且创建一个实例 12function Foo()&#123;&#125;var f1 = new Foo() 上述代码发生了几件事 1.定义了一个函数，定义函数时会根据特定的规则为该函数创建一个prototype属性，这个属性指向一个对象，即函数的原型。这个对象也会默认带有一个constructor属性，指向函数本身； 2.通过new操作符调用这个函数，并返回赋值给f1，f1就是构造函数Foo的实例。f1是一个对象，在js中，所有的对象在创建时都会被添加一个[[prototype]]属性，目前大部门浏览器可以通过proto属性访问[[prototype]]属性(此处可以认为是同一个东西)，es5中可以使用Object.getPrototypeOf可以直接访问这个属性； 3.f1对象的[[prototype]]指向了创建f1的构造函数Foo的原型属性Foo.prototype,这个属性连接的是f1和构造函数原型，而不是连接的构造函数本身，可以通过以下方式验证 12f1.__proto__ === Foo.prototype //trueObject.getPrototypeOf(f1) === Foo.prototype // true 我们常说的实例可以调用构造函数原型上的方法，就是因为[[prototype]]属性的存在，当实例访问自身身上不存在的属性or方法时，会尝试通过[[prototype]]属性去访问创建它的构造函数Foo的原型上即Foo.prototype是否存在对应的属性，我们可以看到图上最上面的线 f1.proto –&gt; Foo.prototype 2.原型链 我们同样可以看到，如果当f1通过proto访问Foo.prototype后，发现Foo.prototype还是没有找到对应的属性或方法,那么此时f1还会继续查找。 别忘了Foo.prototype也是一个对象，既然是对象那么就是Object的实例，那么Foo.prototype也就自然的有一个[[prototype]]属性指向Object的原型了，可以用一下方式验证。 12Foo.prototype.__proto__ === Object.prototype // trueObject.getPrototypeOf(Foo.prototype) === Object.prototype // true 所以，当f1通过proto访问Foo.prototype后发现找不到想要的属性或方法，那么会继续根据Foo.prototype.proto访问Object.prototype，如果找到了会访问该属性或调用该方法，且会停止查找。如果还是没有找到，根据图上来看，最后会查找到null。 f1 -&gt; proto -&gt; Foo.prototype -&gt; proto -&gt; Object.prototype -&gt; proto -&gt; null 这样看着像一条线的逐级查找，且是通过函数的原型来查找，这就是所谓的原型链。 为了验证原型链真的存在，我们还可以举个例子 123f1.toString() // [object Object]Object.prototype.toString.call(f1) // [object Object]f1.toString === Object.prototype.toString // true 很明显，我们并没有在f1上定义一个toString方法，包括在创建它的构造函数的原型中也没有，而在Object.prototype中有一个toString方法，且二者是相等的，所以f1调用toString方法也就是通过原型链去查找最后在Object.prototype找到了对应的方法。 2.函数也有原型链 我们继续看图，在javascript中，函数也是对象的一种，自然函数也是有原型链的，而函数实际上都是Function的实例，自然酥油函数都会有一个[[prototype]]指向Function.prototype了，另外不管是普通函数还是内置的函数比如Function、Object、Array等，既然它们是函数，也会有一个[[prototype]]指向Function.prototype。 1234Foo.toString() // \"function Foo() &#123;&#125;\"Object.prototype.toString.call(Foo) // [object Function]Function.prototype.toString.call(Foo) // \"function Foo() &#123;&#125;\"Foo.toString === Function.prototype.toString // true 此时调用Foo.toString方法，会发现与Object.prototype.toString方法调用的结果不一样，这是因为Foo通过原型链，在Foo.prototype上就找到了对应的方法，然后停止查找了。 另外，在这幅图中，有一个循环的指向 Object -&gt; proto -&gt; Function.prototype -&gt; proto -&gt; Object.prototype -&gt; constructor -&gt; Object 这也很好理解，Object是函数，所以会有原型链查找到Function.prototype再查找到Object自己的原型Object.prototype，而Object.prototype是对象，且在创建的时候会自动添加上一个constructor的属性指向Object函数自身，所以会有这么一个看似是“鸡生蛋，蛋生鸡”的结果。 4.原型链相关 如何判断两个对象是否通过原型链有关联呢，我们可以通过instanceof操作符和Object.prototype.isPrototypeOf来判断 123456f1 instanceof Foo // truef1 instanceof Object // truef1 instanceof Function // falseFoo.prototype.isPrototypeOf(f1) // trueObject.prototype.isPrototypeOf(f1) // true 当Foo.prototype自身没有isPrototypeOf时，通过原型链查找到了Object.prototype上找到了对应的方法。 instanceof和isPrototypeOf的区别： instanceof是用原型链上查找的各个函数的原型，再通过该原型对应自身的函数判断，即instanceof右侧的值为函数且该函数的原型出现在左侧的值的原型链上 isPrototypeOf则是直接通过原型对象查找，不经过原型的函数本身了 二者比较而言还是isPrototypeOf更通用更直观一些。","tags":[{"name":"JS原型","slug":"JS原型","permalink":"http://yoursite.com/tags/JS原型/"},{"name":"JS原型链","slug":"JS原型链","permalink":"http://yoursite.com/tags/JS原型链/"}]},{"title":"2019面试总结","date":"2019-06-21T03:05:11.000Z","path":"2019/06/21/2019面试总结/","text":"1.浏览器引擎内核分为脚本引擎和渲染引擎 分别说一下 IE Chrome FF Opera等的内核 谷歌的脚本引擎V8 w3help去看 使用Trident的是IE 使用Gecko的是Mozilla Firefox 使用Presto的是opera 使用WebKit的有苹果的safari，谷歌的chrome， Chrome chromium webkit blink V8 node的关系 2.不要再html中直接引入源代码,经过下面的处理：lint检查错误babel 可以 编写es6的代码uglify 或者minify把代码缩小bundle把多个文件合并为一个 这就就一个 —暗夜的风雪 1.介绍项目2.svg与canvas的不同 热力图应该用哪一个 svg绘制出来的每一个图形元素都是独立的DOM节点，可方便后期绑定事件或修改，而canvas输出的是一整幅画布； svg输出的图形是矢量的，后期可以修改参数来自由放大缩小，无失真，canvas输出标量画布，就像一张图片一样。 3.介绍下vue开发时 如何规划项目，主要讲组件 通信状体管理 路由， 通信方式，打包发布 4.浏览器渲染过程 渲染引擎和JS引擎 5.webpack本地开发怎么解决跨域 proxyTable: { ‘/api’: { target: ‘’, changeOrign: true, pathRewrite: { ‘^/api’: ‘’ } } } 6.webpack的原理，哪里是词法分析还是语法分析，具体什么？ 7.loader和plugin区别 分别做什么 8.vue中v-dom原理 为什么高效 和模板引擎有什么区别 9.diff算法 10.深拷贝，写代码。各种数据类型那些在堆栈上？Jquery的extend是浅拷贝还是深拷贝？JSon的方法实现有什么缺陷 11.原型链 写代码不能用Es6的class extends 12.service worker 13.websocket 14.flex布局栅格 实现水平垂直居中 看TCP/IP 操作系统 算法 数据结构 操作系统的调度算法输入URl开始到页面显示说一遍 : url -&gt; host -&gt; dns -&gt;代理服务器 -&gt;5层协议 -&gt; XXXjs的单线程模式 为什么是单线程 进程 线程 协程 线程：多线程 单线程 有限状态机 1.http缓存2.canvas和webgl的一些api使用3.canvas中如何做两个图形之间的碰撞检测4.redux的一些流程5.react的diff算法6.setState后react做了什么事7.react的key是干嘛用的8.webpack提取css代码用哪个loader9.redux-saga的原理 promise的实现原理10.如何检测出栈溢出 js内存泄露常见的原因，预防措施 11.浏览器和node中对于eventloop的实现的不同 12.canvas动画的性能优化会提到settimeout和requestanimationframe有关系为什么使用settimeout性能差13.资源请求中没有任何的缓存相关响应头 浏览器会采用什么样的缓存策略14.git的rebase和merge 2.get和post区别 get和post的性能差距大不大3.restful的API设计4.http基于udp还是tcp? tcp和Udp什么区别 几次握手几次断开， 为什么要这样设计？如果不这样设计 会发生什么5.跨域 追问正向代理和反向代理 追问websocket跨域6.vue/react兄弟组件通信7.200万条数据插入vue的data 不添加watcher 怎么实现8.redux是那个架构的实现9.fluex架构的单向数据流有哪些部分组成 和vuex的不同点10.jsx怎么被解析 用 AST 说说具体过程 解析jsx用了babel和webpack的什么插件或者loader11.组件热加载方法12.写一个观察者模式 写一个单列模式14.遍历一个树形对象 1.JS函数的闭包以及遍历的生命周期2.Js是不是面相对象的编程语言？Js对象的面向对象的原型继承、原型链3.什么是websocket协议4.http协议 后面多个s，也就是https 有何区别 请详说http的状态码5.实现跨域的解决方法有哪些（可选任何一种来解释） JSOP跨域为什么只能用get请求6.如何实现前后端分离7.移动端的rem以及flex弹性布局解释一下8.页面性能优化有哪些 请列举9.localStorage和sessionStroage是什么 请解释一下其生命周期10.谈谈this对象的理解 1.数组去重，数组最大 判断一个变量是否是数组 —gakki1.原生js dom 正则 安全 设计模式 http webpack js基础 闭包 异步方法 vue基础 怎么实现双向绑定 —–面试要求1.js 闭包 this的指向 双向绑定原理以及实现（数据劫持与代理） 如何调试node程序， 如何优化js性能2.css 如何扩展css功能 高清方案 vw支持方案 动画性能优化3.算法 如何计算时间/空间复杂度 动态规划的理解和运用4.框架/选型 React/Vue选型分析（JSX/模板语法，单/双向绑定,成员交接成本，扩展性等各项属性对比） Angular性能卖点(web worker多进程，自带服务端渲染 优化后的脏检查机制) 部署技术选型的药店（有哪些成本和收益 举列子） React优化方式 5.webpack构建 多页面架构可能遇到的问题 代码分割方式 性能以及提速方式 缓存可能存在的问题以及解决方式 插件原理 1.vue中v-dom的理解2.双向绑定实现 观察者模式是什么 MVVM架构又是什么 getter和setter发生在哪个阶段3.diff算法 树的遍历 为什么复杂度是O(n)4.单页应用路由的原理5.url中#的作用 带#好会不会发生请求出去6.Vue中create()和mounted()的内部区别7.vue中methods和computed()的区别8.js基础类型判断9.Set和Map的区别 常用来做什么 底层实现10.Es6箭头函数 怎么样 内部变量的作用域11.splice()和slice()有什么区别 如果要实现替换一个值选用哪个并如何传参数12.如何改变this指向 call apply的区别 实现bind13.创建对象的方法14.es6的class extends是哪种继承方式的语法糖 es5的实现代码15.垃圾回收算法： 两种算法分别在哪些引擎上被采用 标记清除法是如何内部处理循环引用问题的16.闭包 闭包的作用 模块模式的实现 17.跨域的方式 cors设置那几个头 简单请求和复杂请求的区别 复杂请求发送了几次请求 第一次请求方法是什么 jsonp的原理 webpack是哪种方式实现跨域的 如何编辑配置文件18.数据结构中的数组和链表的区别 翻转一个数组 和翻转一个单链表呢19.cookie和session的区别 如果后端存储了多条session哪一条有效 如果expries有效时间也一样呢20.node.js的高并发原因 node.js 的异步顺序21.express和koa的区别 ORM用没有 如何理解 1.AST Babel原理2.手写二叉树 背包 动态规划来一波儿 —-知乎 58招聘技术1.基础知识面 闭包 es6-class： 类的静态成员和动态成员的区别 重点考察多态和类型的设计 比如说minxin和decorator map/redurce/filter/find promise和 async await 基础算法：比如链表 如何实现hash算法 归并排序的复杂度 前端常用的设计模式：比如说subscribe ovservable等 进程和线程的区别 (什么线程同步) 2.解决问题面 组件接口设计：比如设计一个表单组件 picket –基于react或者vue 具体的工具(gulp webpack rollup)考察具体的只是点 3.知识边界面 考察一个稍微复杂一点的shell知识点(如awk,xargs等命令) 问一个数据库相关知识中有深度的一点问题（如什么是锁） 问一个缓存相关的问题（如什么是缓存穿透） React/Vue的virtual dom实现原理 js新特性掌握深度（symbol-observable 什么是web-asm） 前端方向把握（pwa/electron/react-native） node.js的学习情况 ——-react群MD5加密原理 V8原理 Vue源码 React源码浏览器渲染原理小图用base64图片为什么就可以减少请求 ——-面试题1.阐述cookies sessionStorage和localStorage的区别2.简述es6中的let const3.css3中box-sizing的值以及作用4.当new Foo()发生了什么5.浏览器渲染原理6.代码优化基本方法 —–面试题html方向1.Html语义化理解2.svg动画与canvas动画的使用场景（优劣势）3.如何实现一个搜索高亮的文件树 js方向4.virtual-dom的基本原理以及实现5.Vue的MVVM的实现理解6.promise generator async/await的原理解释7.webpack和gulp的理解和使用 8.es6的特性考察 优化了哪些es5的API9.react的diff算法基本原理与源码解释10.什么是函数式编程 js中如何使用函数式编程 浏览器方向11.对GPU渲染动画的理解12.浏览器缓存种类 区别与使用细节13.浏览器有哪些常驻线程 它们的运行机制是怎么样的 哪些线程之间是互斥的14.线程与进程的去呗15.为什么利用多个域名来提供网站资源会更有效？","tags":[]},{"title":"前端网页资源优化加载","date":"2019-01-14T08:13:20.000Z","path":"2019/01/14/前端网页资源优化加载/","text":"前言vue打包的项目,首次加载时间很慢 想要优化一下速度 1.了解资源加载的时序根据Tools for Web DevelopersRequest Timing API生命周期：1.Redircet(重定向)： starTime,redirectTime,redircetEnd2.App Cache(应用程序缓存)：fecthStart3.DNS：domainLookupStart,domainLookupEnd4.TCP： connectStart,secureConnectionStart,connectEnd5.Request：requestStart6.Response: responseStart,responseEnd 在DevTools中查看Queuing: 某个请求正在排队，在HTTP1上，浏览器只允许每个源拥有6个TCP连接Stalled/Blocking: 请求等待发送请求的时间Proxy Negotiation: 与代理服务器协商所用的时间DNS Lookup: 执行DNS查询所需要的时间，每一个新域都需要完整的往返才能执行DNS查询Initial Connection/Connecting: 建立连接所需要的时间，包括TCP握手/重试 和协商SSL的时间SSL: 完成SSL所需要的时间Requeset Sent/Sending: 发出网络请求所需要的时间，通常不到一毫秒Waiting(TTFB): 等待初始相应所用时间，也称为第一字节时间Content DownLoad/DownLoading: 接收响应数据所用的时间 诊断网络问题1.排队或停止阻塞单个客户端检索的资源太多，在HTTP1.0/1.1连接协议中限制每个域名最多执行6个TCP连接，前6个请求后面的需要等待-&gt;实现分域，用多个子域名提供服务资源，将资源拆分到多个子域中，均匀分配HTTP2.0中已经实现了多路复用连接，不需要修改 2.接收到第一个字节时间很慢(绿色很长)客户端和服务器端网络条件差 优化响应速度,优化数据库查询，缓存，修改web服务器配置服务器响应程序很慢 3.加载很慢(蓝色很长) 发送更少字节，压缩图片大小 2.避免无效/多余请求如果发生在网页请求开始阶段,会极大影响首屏渲染 2.1避免不必要的重定向301,302 303/307重定向比较常见，不必要的重定向浪费时间 trailing slash(末尾斜杠): 是否含斜杠都响应相同内容 2.2尽量避免404静态资源返回404浪费宽带,拖延页面渲染时间404浪费一个TCP往返时间 + 其他时间一个浏览器6个TCP并发，404会占用一个，导致其他会有延迟 favicon 浏览器会请求网址图标,如果不设置404 2.3正确标签的src3.资源及其规则主要是指JS/CSS/IMG 3.1资源尽量小,启用压缩图片压到合适，不同设备不同分辨率文本内容使用gzip压缩 3.2CDN与域名收敛CDN与主站不在同一域名，可以避开浏览器同一域名最大6个TCP连接的限制，提高并发下载能力。 3.3合理设计缓存图片，css和js考虑版本迭代 3.4合理的文件合并多个文件or图片合并，减少http请求个数 3.5延迟下载电商图 首屏不加载，按需加载","tags":[]},{"title":"前端文件的上传和下载","date":"2018-09-27T08:13:20.000Z","path":"2018/09/27/前端文件的上传和下载/","text":"1.后台返回二进制流 前端进行下载文件12345678910111213141516171819202122/*** data:二进制的数据** name:下载的包名*/var service = axios.create(&#123; responseType: 'blob', // 返回数据的格式,其可选项是arraybuffer,blob, // document,json,text,stream,默认值为json&#125;)chunkBlob(data, name) &#123; if (!e || !window.FileReader) return // 看支持不支持FileReader var reader = new FileReader() // 需要支持fileReader reader.readAsDataURL(data) reader.onload = function(e) &#123; var a = document.createElement('a') a.download = name + Date.now() + '.zip' a.href = e.target.result document.body.appendChild(a) a.click() document.body.removeChild(a) &#125;&#125; 2.返回要下载的文件名，通过 a 标签去下载123456var a = document.createElement('a')a.download = fileName // 下载的文件名a.href = baseURL + fileNamedocument.body.appendChild(a)a.click()document.body.removeChild(a) 3.使用 formData 上传文件12345678910111213&lt;!-- 点击按钮就上传 --&gt;&lt;button @click=\"clickInput\"&gt;上传&lt;/button&gt;&lt;input type=\"file\" ref=\"file\" @change=\"uploadFile\" style=\"display:none\"/&gt;&lt;!-- 本地图片需要预览 采用label的for id --&gt;&lt;label for=\"inputFile\"&gt; &lt;img width=\"148\" height=\"148\" :src=\"previewSrc\" v-show=\"previewSrc\"&gt; &lt;div class=\"img-upload\" v-show=\"!previewSrc\"&gt; &lt;i class=\"el-icon-plus\"&gt;&lt;/i&gt; &lt;input class=\"image-input\" id=\"inputFile\" accept=\"image/jpeg,image/jpg,image/png\" type=\"file\" @change=\"changeImg($event)\" /&gt; &lt;/div&gt;&lt;/label&gt; 123456789101112131415161718192021222324.img-upload &#123; display: inline-block; text-align: center; background-color: #fbfdff; border: 1px dotted #d9d9d9; border-radius: 6px; width: 148px; height: 148px; line-height: 146px; vertical-align: top; box-sizing: border-box; &amp;:hover &#123; color: #67c23a; border-color: #67c23a; cursor: pointer; &#125; .el-icon-plus &#123; font-size: 28px; color: #8c939d; &#125; .image-input &#123; display: none; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041function clickInput() &#123; this.$refs['file'].click()&#125;function uploadFile(e) &#123; let files = e.target.files // 单个or多个文件 let formData = new FormData() formData.append('apk', files[0]) formData.append('other', '其他属性值') requestFileDate(formData).then(res =&gt; &#123; console.log(res.data) &#125;)&#125;function changeImg(e) &#123; var imageFile = e.target.files[0] if (!e || !window.FileReader) return // 看支持不支持FileReader let reader = new FileReader() reader.readAsDataURL(imageFile) // 这里是最关键的一步，转换就在这里 let _this = this reader.onloadend = function() &#123; _this.previewSrc = this.result &#125; this.reqFormData = new FormData() this.reqFormData.append('base_image', imageFile) e.srcElement.value = '' // 清空防止上传图片时选择相同文件无法触发change事件&#125;// 设置axios的headers['Content-Type'] = 'multipart/form-data'export function requestFileDate(data) &#123; return request(&#123; url: '/upload', method: 'post', data: data, headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125;)&#125;","tags":[]},{"title":"Js中Array的各种操作","date":"2018-08-30T11:41:20.000Z","path":"2018/08/30/Js中Array的各种操作/","text":"前言作为一个资深的前端 各种数组的操作(包括数组对象的操作)非常的频繁 在加上各种 es5+的新方法 更是好用 1. 关于一个程序员的表单突然在某个群里看到 程序猿给妹纸写一个假吧意思很浪漫的 颜色随机的代码 求优化 123456789101112131415161718var strs = ''for (var i = 1; i &lt;= 952; i++) &#123; strs += `,想你的第$&#123;i&#125;天`&#125;var style = []for (var i = 1; i &lt;= 952; i++) &#123; var color = '', colorStr = 'abcdef1234567890'.split('') for (var j = 0; j &lt; 6; j++) &#123; color += colorStr[Math.floor(Math.random() * 16)] &#125; style.push(`color:#$&#123;color&#125;`)&#125;var newstrs = strs.split(',').map(item =&gt; &#123; return `%c$&#123;item&#125;`&#125;)console.log(`%c$&#123;newstrs&#125;`, ...style) 然后人家一行代码,我就恶补了好多知识点，阿西吧 1234567891011a = new Array(951).fill()console.log( a.map((_, i) =&gt; `%c想你的$&#123;i + 1&#125;天`).join(', '), ...a.map( _ =&gt; 'color:#' + Math.random() .toString(16) .substr(2, 6) )) 然后大佬们开始各种秀，作为小白的我已经悄咪咪的拿小本本记下来了 1234567891011new Array(951).fill().map((item, i) =&gt; `想你的$&#123;i&#125;天`)Array.from(&#123; length: 100 &#125;).map((item, i) =&gt; `想你的$&#123;i + 1&#125;天`)Array.from(&#123;length: 10&#125;).map((_,i) =&gt; i) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]Array.from(Array(10).keys()) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][...Array(10).keys()] //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]Array(5).fill().map(new Function().call, Number) //[0, 1, 2, 3, 4] 2. Array.fill()具体地址 MDN Array.fill 12345678910/** * @params value 填充的值 * @params start 填充起始位置 默认为0 * @params end 填充末尾位置(但不包含) 默认为this.length */Array.fill(value, [start, end]) // 填充的value 数组的起始位置start 末尾位置end(不包含end) [(1, 2, 3, 4, 5)].fill(0, 2, 4) // [1,2,0,0,5]new Array(5).fill() // [undefined, undefined, undefined, undefined, undefined] 3. Array.from()具体地址 MDN Array.from 123456789101112/** * @params arrayLike 想要转换成数组的伪数组对象或可迭代对象(Map,Set对象的值)。 * @params mapFn 新数组中的每个元素会执行该回调函数。 * @params thisArg 执行回调函数 mapFn 时 this 对象。 */Array.from(arrayLike, [mapFn, thisArg]) // 伪数组or可迭代的对象转换成数组Array.from([1, 2, 3, 4, 5], x =&gt; x * x) // [1,4,9,16,25]Array.from(&#123; length: 5 &#125;, (_, i) =&gt; i + 1) // [1, 2, 3, 4,5]Array.from(new Set([1, 2, 3, 4, 2, 5, 6, 3, 6])) // [1, 2, 3, 4, 5, 6] 4. Array.reduce()具体地址 MDN Array.reduce 123456789101112131415/** * @params callback 对数组每个元素处理的回调函数(prev,current,currentIndex,array) * @params initValue 回调函数的初始值 若没有则使用数组的第一个元素 */Array.reduce(callback, [initValue]) // 伪数组or可迭代的对象转换成数组 /** * callback(prev,current,index,array) initValue * initValue有初始值时 prev = initValue index = 0 * initValue没有值时 prev = array[0] index = 1 */ [1, 2, 3, 4, 5].reduce(function(prev, current, index, array) &#123; return prev + current &#125;) | prev | current | index | array |返回值 || 1(数组第一个值)| 2(数组第二个值) | 1(无初始值为 1) | [1,2,3,4,5] |3 || 3 | 3 | 2 | [1,2,3,4,5] |6 || 6 | 4 | 3 | [1,2,3,4,5] |10 || 10 | 5 | 4 | [1,2,3,4,5] |15 | 123[1, 2, 3, 4, 5].reduce(function(prev, current, index, array) &#123; return prev + current &#125;,10) | prev | current | index | array |返回值 || 10(初始值) | 1(数组第一个值) | 0(有初始值为 0)| [1,2,3,4,5] |11 || 11 | 2 | 1 | [1,2,3,4,5] |13 || 13 | 3 | 2 | [1,2,3,4,5] |6 || 16 | 4 | 3 | [1,2,3,4,5] |20 || 20 | 5 | 4 | [1,2,3,4,5] |55 | 1234567891011121314151617181920212223242526272829303132// 常用例子//1.数组元素求和[1,2,3,4,5].reduce((a,b) =&gt; a+b) // 15//2.二维数组转化为一维数组[[1,2],[3,4],[5,6]].reduce((a,b) =&gt; a.concat(b),[])//3.计算数组中元素出现的次数[1, 2, 3, 1, 2, 3, 4].reduce((items, item) =&gt; &#123; if(item in items)&#123; items[item]++; &#125;else&#123; items[item] = 1; &#125; return items;&#125;,&#123;&#125;) //&#123;1: 2, 2: 2, 3: 2, 4: 1&#125;// 4.数组去重①[1,2,3,4,3,4,5,2].reduce((init,current)=&gt;&#123; if(init.length === 0 || init.indexOf(current) === -1)&#123; init.push(current) &#125; return init&#125;,[])// 4.数组去②[1,2,3,4,3,4,5,2].sort().reduce((init,current)=&gt;&#123; if(init.length === 0 || init[init.length -1 ] !=== current)&#123; init.push(current) &#125; return init&#125;,[]) 5.常用的各种操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 1.对象数组中筛选出指定条件的某个字段数组[&#123; select: true, value: 1 &#125;,&#123; select: false, value: 2 &#125;,&#123; select: true, value: 3 &#125;].filter(item =&gt; item.select).map(item =&gt; item.value)function test(arr) &#123; var newArr = [] arr.map(item =&gt; &#123; if (item.select) &#123; newArr.push(item.value) &#125; &#125;) return newArr&#125;// 2.拷贝一个新对象并且添加新的属性var excelJson = (this.uploadPersonStatus = excelJson.map(v =&gt; &#123; return &#123; status: '待上传', ...v &#125;&#125;))// 3.衍生出来的就是数组去重 // 1).使用es6的Set Array.from(new Set(arr))[...new Set(arr)]// 2).使用reduce indexOffunction unique(arr)&#123; if(!Array.isArray(arr))&#123; console.log('type error') return false &#125; arr.reduce((init,current) =&gt; &#123; if(init.length === 0 || init.indexOf(current) === -1)&#123; init.push(current) &#125; return pre &#125;,[])&#125;// 3).使用forEach indexOffunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; var array = [] arr.forEach((item,index) =&gt; &#123; if(array.indexOf(item) === -1)&#123; array.push(item) &#125; &#125;) return array&#125;// 4).利用includesfunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; var array = [] arr.forEach((item,index) =&gt; &#123; if(!array.includes(item))&#123; array.push(item) &#125; &#125;) return array&#125;// 5).利用sortfunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; var arr = arr.sort() var array = [arr[0]] for(let i = 1,j= arr.length;i&lt;j;i++)&#123; if(arr[i] !== arr[i-1])&#123; array.push(arr[i]) &#125; &#125; return array&#125;// 6). 利用filterfunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; return arr.filter((item,index) =&gt; &#123;return arr.indexOf(item,0) === index&#125;)&#125;// 4.不使用for进行1-100输出Array.from(&#123; length: 5 &#125;, (_, i) =&gt; i + 1) // [1, 2, 3, 4,5]Array(5).fill().map((item,index) =&gt; index + 1) // [1, 2, 3, 4,5]Array.apply(null, &#123;length: 5&#125;).map(Number.call, Number) // [0, 1, 2, 3, 4]Array.from(Array(5).keys()) // [0, 1, 2, 3, 4][...Array(5).keys()] // [0, 1, 2, 3, 4]","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"前端面试题汇总","date":"2018-08-28T10:44:20.000Z","path":"2018/08/28/前端面试题汇总/","text":"专门收集的各种面试题，包括面试者or被面试者的出题https://www.toutiao.com/i6605816147252085261/ 1.各种模块化node exports和module.exports的区别还有说说require.js 2.webpack,gulp等打包1.就是webpack和gulp有啥区别，是如何实现的？ 有没有自己配置过webpack 多入口配置 常用插件，有没有自己写过插件？ 环境区分 3. js基础基本数据类型基础类型用啥区别，复杂类型用啥区别 window.onload和jq ready的区别我也没回答上 1.深浅度拷贝 2.如何使得a ==1 &amp;&amp; a == 2 &amp;&amp; a== 3 为true 3.编写一个forEachCustom函数，要求拥有和数组的forEach一样的功能 4.用一句话写出下面函数的函数体，实现输出三个中的最大值 5.函数柯里化 event loop 作用域 6.原型链，继承的几种方式，排序，柯里化，设计模式， 6.let a=0.0000009;let b = parseInt(a); console.log(b);输出结果是什么?为什么? parseInt转换字符串 原型链 和 事件循环 原型链，EventLoop，es6， call，apply，on，bind的区别bind,call,apply的区别是什么 4.null和undefined区别 5.typeof 和instanceof区别 6.this的理解，以及箭头函数this还有箭头函数，this指向 7.原型链和继承 闭包，为什么使用闭包？8.闭包以及使用场景 闭包的应用场景 9.跨域解决办法 10.控制输入间隔 throttle 内置对象 判断未知变量的类型 Object.prototype.toString.call 原生ajax将字符串转换成数字创建，复制，移动，删除元素 4.ES6class 私有变量babelbabel如何解析的AST了解吗 babel插件怎么写 5.同步异步执行顺序settimeout和promise.then哪个先执行 setTImeout跟js的event loop有关 js的异步区分宏任务和微任务。。。async的异步属于微任务，优先级高于setTimeout react 同步异步 异步处理 6. http请求以及状态码403http状态http状态码 常用浏览器内核还是要记一下的 页面中大量图片请求是否会每次都建立TCP连接访问一个网址从访问到渲染发生了什么？ 7.各种底层原理和源码2.webpack和vue底层实现原理ajax跨域原理，vue绑定原理，webpack打包原理，http三次握手，http工作原理，ajax同步异步具体区别，mvvm原理是什么，线程和进程的区别知道非对称加密的原理吗 react-route的实现原理箭头函数怎么实现的 MD5加密原理V8原理Vue源码React源码浏览器渲染原理 8.关于Vue生命周期 computed和 watcher vue的modelsoltvue封装组件(3次)自定义指令 $on $emit观察者模式 vue鉴权处理 vuex模块问到vuex的实现原理 就是先有一个全局store 然后实现一下双向绑定 action异步 vue数据绑定原理 Object.defineProperty 9.css样式web语义化 css3伪类 1.两种盒模型的区别；IE8下的盒模型 浮动会出现的问题，怎么解决bfc清除浮动原理 2.css3中transition 和 animation区别 3.水平垂直居中 Doc文档的类型和区别 JavaScript解析的时候什么依赖css什么时候不依赖css 10.为什么？小图用base64为什么就可以减少请求 tcp为什么要设计成三次握手 img标签的默认display，为什么img可以设置宽高 11.Reactredux的理念 —————react—————– 提到react，可以从这几方面着手1、为什么用react，用react带来了什么好处2、react进阶、剖析3、跟其他方案的对比（vue，ng），各自的优缺点（是什么让你坚持使用react） 回到项目，比如是1个每天只有几百人访问的小项目。那么，你可以考虑：1、如果突然变成每天一百万人访问，那么可能遇到什么问题，比如性能上的2、性能优化要从哪些方面着手3、怎么确保线上项目的稳定性 —————-react—————– 12.其他后端给的在线文档用什么工具生成 swagger除了element之外还用过什么UI库 iview vux ydUI前端异常处理xss csrf就不说了，居然还问到dns劫持，运营商劫持","tags":[]},{"title":"基础小知识笔记","date":"2018-08-09T08:13:20.000Z","path":"2018/08/09/基础小知识笔记/","text":"1三种数据结构：1.堆 (key-value) 类似于一个书架，根据key找value2.栈 (先进后出) 函数调用栈3.队列 (先进先出) 安检排队 4.变量对象和基础数据类型 变量对象：js执行上下文生成后，会创建一个变量对象的特殊对象(基础数据类型会保存在变量对象中) 五大基础数据类型：Null，Undefined，Boolean，String，Number 5.引用数据类型和堆内存引用数据类型的值是保存在堆内存中的，变量对象中保存的是一个与对堆内存相关联的地址var obj = {name:’liyanyan1994’,age:24} 6.内存空间管理js的内存生命周期：1.分配需要的内存 2.读写内存操作 3.不需要就释放 var a = 10; console.log(a + 10) a = nulljs有垃圾自动回收机制：通过标记清除算法找到不再使用的变量，主要是全局变量","tags":[]},{"title":"Vue中使用Echarts","date":"2018-08-09T04:19:11.000Z","path":"2018/08/09/Vue中使用Echarts/","text":"前言大部分的后台系统都会有很多的数据，为了看得更直观，一般都会使用图表，如常见的 hightChart，chart,echarts，其中百度的 echarts 我认为是相对来说比较好的，个人一直在再使用，今天主要讲解在 vue 中使用 echarts 1.完整的引入 echarts1.1 安装 echartsnpm install echarts –save 1.2 在组建中直接 import 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div :class=\"className\" :style=\"&#123;height:height,width:width&#125;\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import echarts from 'echarts'export default &#123; props: &#123; className: &#123; type: String, default: 'chart', &#125;, width: &#123; type: String, default: '200px' &#125;, height: &#123; type: String, default: '200px' &#125; &#125;, data() &#123; return &#123; chart: null &#125; &#125;, mounted() &#123; this.initChart() &#125;, beforeDestroy() &#123; if (!this.chart) &#123; return &#125; this.chart.dispose() this.chart = null &#125;, methods: &#123; initChart() &#123; this.chart = echarts.init(this.$el) this.setOptions(&#123; '***各种options****' &#125;) &#125; &#125;&#125;&lt;/script&gt; 好处：直接引入整体的echarts,不需要单独引入，很简单坏处：整个包的体积很大，打包的时候可以进行优化 1.3 单独的一个独立组件大部分情况下，如果多个地方使用同一样的图表，就可以写成一个单独的组件进行多次复用，与上面大部分相同，只是需要传递一个props的原始数组，然后进行setOptions,值得注意的是，一般需要根据父组件的日期选择不同，chart的数据需要进行变化，当前使用的是watch某个props属性，然后进行相应的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344export default&#123; props: &#123; orignChartData: &#123; type: Array &#125; &#125;, mounted() &#123; if(this.orignChartData.length !== 0)&#123; this.initChart() &#125;else &#123; return null &#125; &#125;, watch: &#123; orignChartData: &#123; deep: true, hanlder(val)&#123; if(val.length !== 0)&#123; '这里可以算options里面的一些东西' if(this.chart)&#123; this.chart.clear() this.settingOptions() &#125;else&#123; this.initChart() &#125; &#125;else &#123; if(this.chart)&#123; this.chart.clear() &#125; &#125; &#125; &#125; &#125;, methods: &#123; initChart()&#123; this.chart = echarts.init(this.$el) this.settingOptions() &#125;, settingOptions()&#123; '这里可以算options里面的一些东西' this.chart.setOption() &#125; &#125;&#125; 2.按需加载使用echart，减少体积2.1新建一个‘@/lib/echarts.js’12345import echarts from 'echarts/lib/echarts'import 'echarts/lib/chart/bar'import 'echarts/lib/component/legend'import 'echarts/lib/component/title'export default echarts 在组件中直接import echarts from ‘@/lib/echarts’ 2.2.通过插件babel-plugin-enquire配合实现echarts按需引入下载babel-plugin-enquire插件 npm install babel-plugin-enquire -D 修改.babelrc文件中的配置1234\"plugins\": [ \"...其他插件\", \"enquire\"] 在‘@/lib/echarts.js’123456const echarts = enquire([ 'bar', 'legend', 'title'])export default echarts 2.3在组件中直接引入1import Echart from '@/lib/echarts'","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Echarts","slug":"Echarts","permalink":"http://yoursite.com/tags/Echarts/"}]},{"title":"Vue中使用i18n国际化","date":"2018-08-09T02:28:11.000Z","path":"2018/08/09/Vue中使用i18n国际化/","text":"前言我司主要是针对印尼客户，做的系统每次都要翻译成英文，但是公司内部员工是需要使用中文，就想着需要国际化一下，这样中英文切换就很方便，而且两者都可以使用,系统是基于vue、elementUI的，就查了资料更改。 1. 安装 vue-i18nnpm install vue-i18n –save 2. 新建文件‘@/lang/index.js’该文件主要是导出一个国际化的实例，里面有本地翻译的信息 123456789101112131415161718192021222324252627import Vue from 'vue'import VueI18n from 'vue-i18n'import Cookies from 'js-cookie'import elementEnLocale from 'element-ui/lib/locale/lang/en' // element-ui langimport elementZhLocale from 'element-ui/lib/locale/lang/zh-CN' // element-ui langimport enLocale from './en'import zhLocale from './zh'Vue.use(VueI18n)const messages = &#123; en: &#123; ...enLocale, ...elementEnLocale &#125;, zh: &#123; ...zhLocale, ...elementZhLocale &#125;&#125;// 创建带有选项的 VueI18n 实例const i18n = new VueI18n(&#123; locale: Cookies.get('language') || 'en', // set locale messages // set locale messages&#125;)export default i18n 使用的是ElementUI库 elementEnLocale，elementZhLocale都是element的语言切换enLocale，zhLocale是我本地的语言翻译,在相同的目录下建en.js zh.js 1234567891011121314// en.jsexport default &#123; inputplace: 'please input' title: &#123; headers: 'LaiDian Service Background System' &#125;&#125;// zh.jsexport default &#123; inputplace: '请输入' title: &#123; headers: '来电后台管理系统' &#125;&#125; 3. 把i18n挂载到Vue实例上在main.js中引入lang/index.js123456789101112131415161718192021222324252627282930import Vue from 'vue'import App from './App'import router from './router'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import * as filters from './filters' // global filtersimport './icons' // iconimport store from './store'import i18n from './lang' // 国际化Vue.use(ElementUI, &#123; size: 'small', i18n: (key, value) =&gt; i18n.t(key, value)&#125;)// 注册全局filtersObject.keys(filters).forEach(key =&gt; &#123; Vue.filter(key, filters[key])&#125;)Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, i18n, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 4. 在html模板中使用国际化123456&lt;template&gt; &lt;div class=\"title\"&gt; &#123;&#123;$t('title.headers')&#125;&#125; &lt;/div&gt; &lt;el-input :placeholder=\"$t('inputplace')\"&gt;&lt;/el-input&gt;&lt;/template&gt; 5.页面切换语言这里切换预言是用的vuex的状态管理，给定一个state:language，然后交互的时候进行分发提交，修改本地的i18n语言设置 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;el-col :span=\"12\" style=\"text-align: right;\"&gt; &lt;el-dropdown trigger=\"click\" class='international' @command=\"handleSetLanguage\"&gt; &lt;span class=\"el-dropdown-link\"&gt; &#123;&#123;language==='zh' ? '中文': 'English'&#125;&#125; &lt;i class=\"el-icon-arrow-down el-icon--right\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item command=\"zh\" :disabled=\"language==='zh'\"&gt;中文&lt;/el-dropdown-item&gt; &lt;el-dropdown-item command=\"en\" :disabled=\"language==='en'\"&gt;English&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/el-col&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', computed: &#123; language () &#123; return this.$store.getters.language &#125; &#125;, methods: &#123; handleSetLanguage (lang) &#123; this.$i18n.locale = lang // 这句是重点 this.$store.commit('SET_LANGUAGE', lang) this.$message(&#123; message: 'switch language success', type: 'success' &#125;) &#125; &#125;&#125;&lt;/script&gt; 还有就是状态管理的store,主要是让界面响应式变化 12345678910111213141516171819202122import Vue from 'vue'import Vuex from 'vuex'import Cookies from 'js-cookie'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; language: 'en' &#125;, mutations: &#123; SET_LANGUAGE: (state, language) =&gt; &#123; state.language = language Cookies.set('language', language) console.log('SET_LANGUAGE==', Cookies.get('language')) &#125; &#125;, getters: &#123; language: state =&gt; state.language &#125;&#125;)export default store","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Element-ui","slug":"Element-ui","permalink":"http://yoursite.com/tags/Element-ui/"}]},{"title":"ElementUI后台管理系统中各种注意事项","date":"2018-06-28T12:11:11.000Z","path":"2018/06/28/ElementUI后台管理系统中各种注意事项/","text":"1.使用 svg 组件进行图标引用以前图片一般用 img 来实现,后来因为请求资源太多进行优化，使用雪碧图，但雪碧图修改起来不方便，就使用 font 库，font 的资源图标有限，找图难受使用阿里开源库 iconfont,各种小图标，自定义图标, 使用 symbol 姿势 1.1 创建 icon-component 组件12345&lt;template&gt; &lt;svg :class=\"svgClass\" aria-hidden=\"true\"&gt; &lt;use :xlink:href=\"iconName\"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;export default &#123; name: 'svg-icon', props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass() &#123; if (this.className) &#123; return 'svg-icon ' + this.className &#125; else &#123; return 'svg-icon' &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 1.2 使用 svg-sprite-loader 将 svg 打包成 svg-sprite默认的 vue-cli 对 svg 有处理，为了防止冲突，采用 webpack 的 exclude,include 来处理，代码如下：webpack.base.config.js 中 1234567891011121314151617&#123; test: /\\.svg$/, loader: 'svg-sprite-loader', include:[resolve('src/icons')], options: &#123; symbolId: 'icon-[name]' &#125;&#125;,&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', exclude:[resolve('src/icons')], options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125;&#125;, 1.3 建立@/src/icons/index.js 自动导入图标新建 icons 文件夹下面 svg 文件夹拿来放 svg 格式的图片 index.js 代码如下 123456789import Vue from 'vue'import SvgIcon from '@/components/SvgIcon'// 全局注册icon-svgVue.component('svg-icon', SvgIcon)const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context('./svg', false, /\\.svg$/)requireAll(req) 1.4 在 main.js 中引入 icons1import './icons' // icon ###1.5 在组件中直接使用组件调用 1&lt;svg-icon icon-class=\"password\" /&gt; 2.通过参数 ID 修改 Url 复用同一个页面不进行数据刷新同一个组件中，只是传递的 url 值如 Id 不相同，希望每次都能够请求后台获取数据 最开始是放在 created 中，发现根本不行 通过 watch 监听路由 from,to 筛选当前的路由进行操作 12345678910watch: &#123; $route(to, from) &#123; // 筛选出当前路由name if (to.name === 'levelThree') &#123; console.log(this.$route.query.device_id) this.deviceId = this.$route.query.device_id this.getDeviceInfo() // 请求后台数据 &#125; &#125; &#125;, 3.vue 右键菜单栏https://github.com/vuejs/awesome-vue#context-menu https://github.com/xunleif2e/vue-context-menu 4.含图片的表单上传 formData表单上传主要是利用 new FormData() 一个对象 然后使用 append 方法进行添加 12345onchange(event)&#123; let file = event.target.files[0] let formdata = new FormData() formdata.append('file',file)&#125; 5.自定义弹出框样式内部 scope 不生效 自定义一个 class 然后用全局的样式去覆盖 6.时间问题标准日期：2017-09-19 或 2017-09-19 20:00:00中国标准时间：Mon Oct 23 2017 17:20:13 GMT+0800 (中国标准时间)时间戳：1508750413毫秒数：1508750413000注意：时间戳*1000 就是毫秒数 https://blog.csdn.net/it429/article/details/78341847 结合 elementUI 的 dateTime 使用new Date(val)new Date().setHours(0,0,0) 得到凌晨时间戳new Date().setHours(23,59,59) 最后一秒时间戳 当前时间戳: 毫秒级别new Date().getTime()Date.now() 7.图片上传预览功能思路： 先用 input[type=file]通过 onchange 事件来获取本地的图片，然后用 HTML5 的 File API 的 FileReader 图片本地转成 base64 格式的 url，把这个 url 赋值到用于预览的 src 就好了。 12&lt;img :src=\"preViewImgUrl\" width=\"160\" height=\"120\"/&gt;&lt;input class=\"image-input\" id=\"inputFile\" accept=\"image/jpeg,image/jpg,image/png\" type=\"file\" @change=\"changeImg($event)\" /&gt; 1234567891011121314// 上传图片的onchange事件 changeImg(e) &#123; var imageFile = e.target.files[0] console.log('imageFile===', imageFile) if (!e || !window.FileReader) return // 看支持不支持FileReader let reader = new FileReader() reader.readAsDataURL(imageFile) // 这里是最关键的一步，转换就在这里 let _this = this reader.onloadend = function() &#123; console.log('reader.onloadend======') _this.preViewImgUrl = this.result &#125; e.srcElement.value = '' // 清空防止上传图片时选择相同文件无法触发change事件 &#125; 8.element-ui 按需加载的时候 v-loading 不起作用vue.esm.js?efeb:591 [Vue warn]: Failed to resolve directive: loading 9.预加载的骨架屏幕 https://blog.csdn.net/w178191520/article/details/7913411010.父组件异步获取的值传给子组件 采用 v-if 解决 mounted created 中可以拿到vue 父子组件数据同步 11.获取本地 iplocation.hostnamelocation.portwindow.location.href = url // 直接跳转链接 12. 打包后 404 问题1.整个 css404 修改配置文件的 config/index.js build: {assetsPublicPath: ‘./‘} 2.图片的路径 404 正常情况下引入图片会 background: url(assets/login-bg.jpg) no-repeat center center;需要在 build/utils.js 中添加 123456789if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader', publicPath: '../../' //添加这句话解决图片打包404问题 &#125;)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125; 3.去掉打包的 sourceMap 文件在 config/index.js 中设置 build 下的 productionSourceMap: false 13. 跨域问题自定义请求的时候会产生 options 操作 需要服务器允许自定义请求头的自定义字段 后端需要在 options 请求头中 返回自定义的相同字段 14.vue 自定义指令的封装imgerror.js 123456789101112131415161718192021222324export default Vue =&gt; &#123; Vue.directive('src-err', &#123; inserted(el, data) &#123; if (data.value) &#123; el.src = 'data:img/jpg;base64,' + data.value &#125; else &#123; console.log('into', data.value === '') el.src = require('@/assets/images/img404.png') &#125; &#125;, updated(el, binding, vnode, oldVnode) &#123; console.log('into src-error updated') &#125;, componentUpdated(el, data, vnode, oldVnode) &#123; console.log('into src-error componentUpdated') if (data.value) &#123; el.src = 'data:img/jpg;base64,' + data.value &#125; else &#123; console.log('into', data.value === '') el.src = require('@/assets/images/img404.png') &#125; &#125; &#125;)&#125; main.js 中引入import directives from ‘./directive/imgerror.js’ Vue.use(directives)","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Element-ui","slug":"Element-ui","permalink":"http://yoursite.com/tags/Element-ui/"}]},{"title":"Vscode格式化代码","date":"2018-06-27T07:23:20.000Z","path":"2018/06/27/Vscode格式化代码/","text":"1.Alt+Shift+F格式化代码不成功问题1. vue文件里面的template格式化不成功 安装了vetur插件 =》 文件-&gt;首选项-&gt;设置-&gt;&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot; //格式化vue Template代码 问题2. vue文件里面的js格式化不成功 “prettier.eslintIntegration”: false #之前设置成了true","tags":[{"name":"Vscode","slug":"Vscode","permalink":"http://yoursite.com/tags/Vscode/"},{"name":"Elint","slug":"Elint","permalink":"http://yoursite.com/tags/Elint/"},{"name":"Prettier","slug":"Prettier","permalink":"http://yoursite.com/tags/Prettier/"}]},{"title":"hexo+github搭建属于自己的个人博客","date":"2018-06-22T07:25:56.000Z","path":"2018/06/22/hexo-github搭建属于自己的个人博客/","text":"1. 前言其实平时很少写文章，总觉得自己的水平还不够，又害怕误导别人。但是遇到问题又总想记录下来，毕竟自己工作了一段时间了。还是想自己搭建属于自己的博客，也算是一个温馨的小屋，以后就可以发一些自己总结的文章or遇到的坑or学习笔记。 2. 安装环境 安装node.js 安装Git 有自己的github账号 vscode编辑器 作为一个程序员，这最基本的配置安装肯定是具备的（不会的可以网上搜，有很多教程） 3. 全局安装hexo,搭建基本的博客 使用npm全局安装hexo 1$ npm install -g hexo-cli hexo-cli初始化 使用vscode打开一个文件夹位置,用来存放Blog文件夹，点开vscode的终端输入一下命令123$ npm init &lt;folder&gt; $ cd &lt;folder&gt;$ npm install folder是你的文件夹名称 如 npm init MyBlog 查看默认的博客页面 继续在终端输入 12$ npm g$ npm s 默认会 http://localhost:4000/ 点击就可以查看 4. hexo-cli基本文件夹目录介绍12345678.├── _config.yml # 个人网站的基本信息├── package.json # 依赖的npm包管理├── scaffolds # 模板文件夹├── source # 资源文件夹| ├── _drafts| └── _posts # 默认新生成的页面在此文件夹下└── themes # 主题文件夹,默认下面是landscape主题 5. 自定义博客5.1修改基本的配置信息在_config.yml 根据个人的信息进行填写，详细的配置可以参考Hexo基本配置 主要是填写site下的基本信息,以及要部署的github的repository site配置 1234567# Sitetitle: 博客名称subtitle: 博客二级标题description: 博客的描述,有助于引擎搜索author: 博客作者language: 语言timezone: 时区 github部署配置 12345deploy: type: git repository: github仓库地址 (如:git@github.com:liyanyan1994/liyanyan1994.github.io.git) message: branch: master 5.2下载喜欢的主题hexo提供了很多的主题,详细的可以参考hexo主题进行筛选 这里根据个人喜好进行选择(个人选择的是BlueLake),终端命令输入: 1.1安装主题1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。根_config.ymllink1theme: BlueLake 1.4 本地启动服务器git bash1$ hexo s 5.3自定义样式在thems/BlueLake 修改layout和source的css进行样式修改,就可以得到自己的页面最终的样子： 6.常见的hexo命令终端输入: hexo generate(简写 hexo g) —根据模板生成静态页面 hexo server(简写hexo s) —本地启动服务器,查看静态页面的效果 hexo clean —清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo init [layout] — 新建一篇文章，默认会在source/_posts生成一个名字是title的md文件，layout不填写会使用默认的布局 hexo g -d —生成文件并且部署到github上","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"BlueLake主题","slug":"BlueLake主题","permalink":"http://yoursite.com/tags/BlueLake主题/"}]},{"title":"vue-cli中按需加载elementUI库","date":"2018-06-20T12:13:20.000Z","path":"2018/06/20/vue-cli中按需加载elementUI库/","text":"前言常常用 vue 开发一些管理系统，那么常用的 elementUI 库是大部分人的选择，不管三七二十一 npm install 一波,在 main.js 中直接一起引入，打包的时候才发现包太大，有些组件根本没有用到，于是我采取了按需引入的方法。 1. 安装 element-ui1npm i element-ui -S 2. 按需引入1.1 安装 babel-plugin-component1npm install babel-plugin-component -D 1.2 修改.babelrc在 plugins 中添加数组 1234567&quot;plugins&quot;:[ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] 1.3 在 main.js 中引入所需要的组件，进行注册12345678import &#123; Button, Select &#125; from 'element-ui'const elementComponent = [Button, Select]// 注册elementUI的每个按需引入的组件elementComponent.forEach(item =&gt; &#123; Vue.component(item.name, item)&#125;) 1.4 关于 Message 等自动弹出问题之前一直是按照全局加载的，修改成按需加载之后会出现 Comfirm 自动弹出,在 github 上可以看到问题按需引入 Message 等自动弹出问题 解决的方法是 1.把组件放在原型上 12345678910const MsgBox = MessageBoxVue.prototype.$confirm = MsgBox.confirmVue.prototype.$message = Message# 和以前的操作一样this.$confirm('tips Title', 'Confirm', &#123; confirmButtonText: 'Yes', cancelButtonText: 'Cancel', type: 'warning'&#125;).then(() =&gt; &#123;&#125;) 2.在单页面使用的时候直接引入组件 12345import &#123;MessageBox&#125; from 'element-ui'MessageBox(&#123; # options&#125;) 1.5 国际化国际化其实很简单，直接引入 12345import lang from 'element-ui/lib/locale/lang/en'import locale from 'element-ui/lib/locale'// 设置语言locale.use(lang) 默认给所有的组件设置一个默认的尺寸 1Vue.prototype.$ELEMENT = &#123; size: 'small' &#125; 那么同时设置尺寸和语言怎么设置 1Vue.use(ElementUI, &#123; size: 'small', locale: en &#125;) 3. 使用命令行自定义主题色1.1 全局安装主题生成工具bash1npm i element-theme -g 1.2 初始化变量文件命令行输入 1et -i 会默认的输出一个 element-variables.scss 文件在最外层目录 1.3 修改 scss 的变量打开文件 element-variables.scss,根据需要修改变量如: 12345$--color-primary: #016d9c !default;$--color-success: #36b3b3 !default;$--color-warning: #e6a23c !default;$--color-danger: #f56c6c !default;$--color-info: #50bfff !default; 1.4 编译主题命令行输入 et 就可以产生 theme 文件 因为是按需引入的，故修改.babelrc 的 styleLibraryName 如下： 12345678&#123; \"plugins\": [[\"component\", [ &#123; \"libraryName\": \"element-ui\", \"styleLibraryName\": \"~theme\" &#125; ]]]&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Element-ui","slug":"Element-ui","permalink":"http://yoursite.com/tags/Element-ui/"}]},{"title":"MarkDown语法学习","date":"2018-06-20T08:41:20.000Z","path":"2018/06/20/MarkDown语法学习/","text":"标题一级到六级标题 中间需要一个空格键 一级标题二级标题三级标题四级标题五级标题六级标题引用 这是一个引用 使用&gt;表示就ok 图片与链接插入图片和链接的语法很像，区别在于一个！ 插入链接显示链接的名称demo: liyanyan.github 插入图片！图片名称插入图片的地址需要床图，暂时推荐SM.MS(SM.SM)的服务，生成url就可以demo: 粗体和斜体**一个星号是斜体 这里是斜体 **两个星号是粗体 这里是粗体 表格 表格头 表格头 表格头 Doudou 6月20日 学习MD语法 Liyanyan 6月20日 开始写md 代码框使用tab缩进包含就可以this is a line code 分割线***分割线(连续三个星号)—分割线 列表（*加上空格） 这是第一列 这是第二列 1.这是有序列表第一个 2.这是有序列表第二个","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]