[{"title":"前端文件的上传和下载","date":"2018-09-27T08:13:20.000Z","path":"2018/09/27/前端文件的上传和下载/","text":"1.后台返回二进制流 前端进行下载文件12345678910111213141516171819202122/*** data:二进制的数据** name:下载的包名*/var service = axios.create(&#123; responseType: 'blob', // 返回数据的格式,其可选项是arraybuffer,blob, // document,json,text,stream,默认值为json&#125;)chunkBlob(data, name) &#123; if (!e || !window.FileReader) return // 看支持不支持FileReader var reader = new FileReader() // 需要支持fileReader reader.readAsDataURL(data) reader.onload = function(e) &#123; var a = document.createElement('a') a.download = name + Date.now() + '.zip' a.href = e.target.result document.body.appendChild(a) a.click() document.body.removeChild(a) &#125;&#125; 2.返回要下载的文件名，通过 a 标签去下载123456var a = document.createElement('a')a.download = fileName // 下载的文件名a.href = baseURL + fileNamedocument.body.appendChild(a)a.click()document.body.removeChild(a) 3.使用 formData 上传文件12345678910111213&lt;!-- 点击按钮就上传 --&gt;&lt;button @click=\"clickInput\"&gt;上传&lt;/button&gt;&lt;input type=\"file\" ref=\"file\" @change=\"uploadFile\" style=\"display:none\"/&gt;&lt;!-- 本地图片需要预览 采用label的for id --&gt;&lt;label for=\"inputFile\"&gt; &lt;img width=\"148\" height=\"148\" :src=\"previewSrc\" v-show=\"previewSrc\"&gt; &lt;div class=\"img-upload\" v-show=\"!previewSrc\"&gt; &lt;i class=\"el-icon-plus\"&gt;&lt;/i&gt; &lt;input class=\"image-input\" id=\"inputFile\" accept=\"image/jpeg,image/jpg,image/png\" type=\"file\" @change=\"changeImg($event)\" /&gt; &lt;/div&gt;&lt;/label&gt; 123456789101112131415161718192021222324.img-upload &#123; display: inline-block; text-align: center; background-color: #fbfdff; border: 1px dotted #d9d9d9; border-radius: 6px; width: 148px; height: 148px; line-height: 146px; vertical-align: top; box-sizing: border-box; &amp;:hover &#123; color: #67c23a; border-color: #67c23a; cursor: pointer; &#125; .el-icon-plus &#123; font-size: 28px; color: #8c939d; &#125; .image-input &#123; display: none; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041function clickInput() &#123; this.$refs['file'].click()&#125;function uploadFile(e) &#123; let files = e.target.files // 单个or多个文件 let formData = new FormData() formData.append('apk', files[0]) formData.append('other', '其他属性值') requestFileDate(formData).then(res =&gt; &#123; console.log(res.data) &#125;)&#125;function changeImg(e) &#123; var imageFile = e.target.files[0] if (!e || !window.FileReader) return // 看支持不支持FileReader let reader = new FileReader() reader.readAsDataURL(imageFile) // 这里是最关键的一步，转换就在这里 let _this = this reader.onloadend = function() &#123; _this.previewSrc = this.result &#125; this.reqFormData = new FormData() this.reqFormData.append('base_image', imageFile) e.srcElement.value = '' // 清空防止上传图片时选择相同文件无法触发change事件&#125;// 设置axios的headers['Content-Type'] = 'multipart/form-data'export function requestFileDate(data) &#123; return request(&#123; url: '/upload', method: 'post', data: data, headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125;)&#125;","tags":[]},{"title":"Js中Array的各种操作","date":"2018-08-30T11:41:20.000Z","path":"2018/08/30/Js中Array的各种操作/","text":"前言作为一个资深的前端 各种数组的操作(包括数组对象的操作)非常的频繁 在加上各种 es5+的新方法 更是好用 1. 关于一个程序员的表单突然在某个群里看到 程序猿给妹纸写一个假吧意思很浪漫的 颜色随机的代码 求优化 123456789101112131415161718var strs = ''for (var i = 1; i &lt;= 952; i++) &#123; strs += `,想你的第$&#123;i&#125;天`&#125;var style = []for (var i = 1; i &lt;= 952; i++) &#123; var color = '', colorStr = 'abcdef1234567890'.split('') for (var j = 0; j &lt; 6; j++) &#123; color += colorStr[Math.floor(Math.random() * 16)] &#125; style.push(`color:#$&#123;color&#125;`)&#125;var newstrs = strs.split(',').map(item =&gt; &#123; return `%c$&#123;item&#125;`&#125;)console.log(`%c$&#123;newstrs&#125;`, ...style) 然后人家一行代码,我就恶补了好多知识点，阿西吧 1234567891011a = new Array(951).fill()console.log( a.map((_, i) =&gt; `%c想你的$&#123;i + 1&#125;天`).join(', '), ...a.map( _ =&gt; 'color:#' + Math.random() .toString(16) .substr(2, 6) )) 然后大佬们开始各种秀，作为小白的我已经悄咪咪的拿小本本记下来了 123456789new Array(951).fill().map((item, i) =&gt; `想你的$&#123;i&#125;天`)Array.from(&#123; length: 100 &#125;).map((item, i) =&gt; `想你的$&#123;i + 1&#125;天`)Array.from(&#123;length: 10&#125;).map((_,i) =&gt; i) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]Array.from(Array(10).keys()) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][...Array(10).keys()] //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 2. Array.fill()具体地址 MDN Array.fill 12345678910/** * @params value 填充的值 * @params start 填充起始位置 默认为0 * @params end 填充末尾位置(但不包含) 默认为this.length */Array.fill(value, [start, end]) // 填充的value 数组的起始位置start 末尾位置end(不包含end) [(1, 2, 3, 4, 5)].fill(0, 2, 4) // [1,2,0,0,5]new Array(5).fill() // [undefined, undefined, undefined, undefined, undefined] 3. Array.from()具体地址 MDN Array.from 123456789101112/** * @params arrayLike 想要转换成数组的伪数组对象或可迭代对象(Map,Set对象的值)。 * @params mapFn 新数组中的每个元素会执行该回调函数。 * @params thisArg 执行回调函数 mapFn 时 this 对象。 */Array.from(arrayLike, [mapFn, thisArg]) // 伪数组or可迭代的对象转换成数组Array.from([1, 2, 3, 4, 5], x =&gt; x * x) // [1,4,9,16,25]Array.from(&#123; length: 5 &#125;, (_, i) =&gt; i + 1) // [1, 2, 3, 4,5]Array.from(new Set([1, 2, 3, 4, 2, 5, 6, 3, 6])) // [1, 2, 3, 4, 5, 6] 4. Array.reduce()具体地址 MDN Array.reduce 123456789101112131415/** * @params callback 对数组每个元素处理的回调函数(prev,current,currentIndex,array) * @params initValue 回调函数的初始值 若没有则使用数组的第一个元素 */Array.reduce(callback, [initValue]) // 伪数组or可迭代的对象转换成数组 /** * callback(prev,current,index,array) initValue * initValue有初始值时 prev = initValue index = 0 * initValue没有值时 prev = array[0] index = 1 */ [1, 2, 3, 4, 5].reduce(function(prev, current, index, array) &#123; return prev + current &#125;) | prev | current | index | array |返回值 || 1(数组第一个值)| 2(数组第二个值) | 1(无初始值为 1) | [1,2,3,4,5] |3 || 3 | 3 | 2 | [1,2,3,4,5] |6 || 6 | 4 | 3 | [1,2,3,4,5] |10 || 10 | 5 | 4 | [1,2,3,4,5] |15 | 123[1, 2, 3, 4, 5].reduce(function(prev, current, index, array) &#123; return prev + current &#125;,10) | prev | current | index | array |返回值 || 10(初始值) | 1(数组第一个值) | 0(有初始值为 0)| [1,2,3,4,5] |11 || 11 | 2 | 1 | [1,2,3,4,5] |13 || 13 | 3 | 2 | [1,2,3,4,5] |6 || 16 | 4 | 3 | [1,2,3,4,5] |20 || 20 | 5 | 4 | [1,2,3,4,5] |55 | 1234567891011121314151617181920212223242526272829303132// 常用例子//1.数组元素求和[1,2,3,4,5].reduce((a,b) =&gt; a+b) // 15//2.二维数组转化为一维数组[[1,2],[3,4],[5,6]].reduce((a,b) =&gt; a.concat(b),[])//3.计算数组中元素出现的次数[1, 2, 3, 1, 2, 3, 4].reduce((items, item) =&gt; &#123; if(item in items)&#123; items[item]++; &#125;else&#123; items[item] = 1; &#125; return items;&#125;,&#123;&#125;) //&#123;1: 2, 2: 2, 3: 2, 4: 1&#125;// 4.数组去重①[1,2,3,4,3,4,5,2].reduce((init,current)=&gt;&#123; if(init.length === 0 || init.indexOf(current) === -1)&#123; init.push(current) &#125; return init&#125;,[])// 4.数组去②[1,2,3,4,3,4,5,2].sort().reduce((init,current)=&gt;&#123; if(init.length === 0 || init[init.length -1 ] !=== current)&#123; init.push(current) &#125; return init&#125;,[]) 5.常用的各种操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 1.对象数组中筛选出指定条件的某个字段数组[&#123; select: true, value: 1 &#125;,&#123; select: false, value: 2 &#125;,&#123; select: true, value: 3 &#125;].filter(item =&gt; item.select).map(item =&gt; item.value)function test(arr) &#123; var newArr = [] arr.map(item =&gt; &#123; if (item.select) &#123; newArr.push(item.value) &#125; &#125;) return newArr&#125;// 2.拷贝一个新对象并且添加新的属性var excelJson = (this.uploadPersonStatus = excelJson.map(v =&gt; &#123; return &#123; status: '待上传', ...v &#125;&#125;))// 3.衍生出来的就是数组去重 // 1).使用es6的Set Array.from(new Set(arr))[...new Set(arr)]// 2).使用reduce indexOffunction unique(arr)&#123; if(!Array.isArray(arr))&#123; console.log('type error') return false &#125; arr.reduce((init,current) =&gt; &#123; if(init.length === 0 || init.indexOf(current) === -1)&#123; init.push(current) &#125; return pre &#125;,[])&#125;// 3).使用forEach indexOffunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; var array = [] arr.forEach((item,index) =&gt; &#123; if(array.indexOf(item) === -1)&#123; array.push(item) &#125; &#125;) return array&#125;// 4).利用includesfunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; var array = [] arr.forEach((item,index) =&gt; &#123; if(!array.includes(item))&#123; array.push(item) &#125; &#125;) return array&#125;// 5).利用sortfunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; var arr = arr.sort() var array = [arr[0]] for(let i = 1,j= arr.length;i&lt;j;i++)&#123; if(arr[i] !== arr[i-1])&#123; array.push(arr[i]) &#125; &#125; return array&#125;// 6). 利用filterfunction unique(arr)&#123; if(!Array.isArray(arr))&#123; return false &#125; return arr.filter((item,index) =&gt; &#123;return arr.indexOf(item,0) === index&#125;)&#125;// 4.不使用for进行1-100输出Array.from(&#123; length: 5 &#125;, (_, i) =&gt; i + 1) // [1, 2, 3, 4,5]Array(5).fill().map((item,index) =&gt; index + 1) // [1, 2, 3, 4,5]Array.apply(null, &#123;length: 5&#125;).map(Number.call, Number) // [0, 1, 2, 3, 4]Array.from(Array(5).keys()) // [0, 1, 2, 3, 4][...Array(5).keys()] // [0, 1, 2, 3, 4]","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"前端面试题汇总","date":"2018-08-28T10:44:20.000Z","path":"2018/08/28/前端面试题汇总/","text":"专门收集的各种面试题，包括面试者or被面试者的出题https://www.toutiao.com/i6605816147252085261/ 1.各种模块化node exports和module.exports的区别还有说说require.js 2.webpack,gulp等打包1.就是webpack和gulp有啥区别，是如何实现的？ 有没有自己配置过webpack 多入口配置 常用插件，有没有自己写过插件？ 环境区分 3. js基础基本数据类型基础类型用啥区别，复杂类型用啥区别 window.onload和jq ready的区别我也没回答上 1.深浅度拷贝 2.如何使得a ==1 &amp;&amp; a == 2 &amp;&amp; a== 3 为true 3.编写一个forEachCustom函数，要求拥有和数组的forEach一样的功能 4.用一句话写出下面函数的函数体，实现输出三个中的最大值 5.函数柯里化 event loop 作用域 6.原型链，继承的几种方式，排序，柯里化，设计模式， 6.let a=0.0000009;let b = parseInt(a); console.log(b);输出结果是什么?为什么? parseInt转换字符串 原型链 和 事件流 原型链，EventLoop，es6， call，apply，on，bind的区别bind,call,apply的区别是什么 4.null和undefined区别 5.typeof 和instanceof区别 6.this的理解，以及箭头函数this还有箭头函数，this指向 7.原型链和继承 闭包，为什么使用闭包？8.闭包以及使用场景 闭包的应用场景 9.跨域解决办法 10.控制输入间隔 throttle 内置对象 判断未知变量的类型 Object.prototype.toString.call 原生ajax将字符串转换成数字创建，复制，移动，删除元素 4.ES6class 私有变量babelbabel如何解析的AST了解吗 babel插件怎么写 5.同步异步执行顺序settimeout和promise.then哪个先执行 setTImeout跟js的event loop有关 js的异步区分宏任务和微任务。。。async的异步属于微任务，优先级高于setTimeout react 同步异步 异步处理 6. http请求以及状态码403http状态http状态码 常用浏览器内核还是要记一下的 页面中大量图片请求是否会每次都建立TCP连接访问一个网址从访问到渲染发生了什么？ 7.各种底层原理和源码2.webpack和vue底层实现原理ajax跨域原理，vue绑定原理，webpack打包原理，http三次握手，http工作原理，ajax同步异步具体区别，mvvm原理是什么，线程和进程的区别知道非对称加密的原理吗 react-route的实现原理箭头函数怎么实现的 MD5加密原理V8原理Vue源码React源码浏览器渲染原理 8.关于Vue生命周期 computed和 watcher vue的modelsoltvue封装组件(3次)自定义指令 $on $emit观察者模式 vue鉴权处理 vuex模块问到vuex的实现原理 就是先有一个全局store 然后实现一下双向绑定 action异步 vue数据绑定原理 Object.defineProperty 9.css样式web语义化 css3伪类 1.两种盒模型的区别；IE8下的盒模型 浮动会出现的问题，怎么解决bfc清除浮动原理 2.css3中transition 和 animation区别 3.水平垂直居中 Doc文档的类型和区别 JavaScript解析的时候什么依赖css什么时候不依赖css 10.为什么？小图用base64为什么就可以减少请求 tcp为什么要设计成三次握手 img标签的默认display，为什么img可以设置宽高 11.Reactredux的理念 —————react—————– 提到react，可以从这几方面着手1、为什么用react，用react带来了什么好处2、react进阶、剖析3、跟其他方案的对比（vue，ng），各自的优缺点（是什么让你坚持使用react） 回到项目，比如是1个每天只有几百人访问的小项目。那么，你可以考虑：1、如果突然变成每天一百万人访问，那么可能遇到什么问题，比如性能上的2、性能优化要从哪些方面着手3、怎么确保线上项目的稳定性 —————-react—————– 12.其他后端给的在线文档用什么工具生成 swagger除了element之外还用过什么UI库 iview vux ydUI前端异常处理xss csrf就不说了，居然还问到dns劫持，运营商劫持","tags":[]},{"title":"基础小知识笔记","date":"2018-08-09T08:13:20.000Z","path":"2018/08/09/基础小知识笔记/","text":"1三种数据结构：1.堆 (key-value) 类似于一个书架，根据key找value2.栈 (先进后出) 函数调用栈3.队列 (先进先出) 安检排队 4.变量对象和基础数据类型 变量对象：js执行上下文生成后，会创建一个变量对象的特殊对象(基础数据类型会保存在变量对象中) 五大基础数据类型：Null，Undefined，Boolean，String，Number 5.引用数据类型和堆内存引用数据类型的值是保存在堆内存中的，变量对象中保存的是一个与对堆内存相关联的地址var obj = {name:’liyanyan1994’,age:24} 6.内存空间管理js的内存生命周期：1.分配需要的内存 2.读写内存操作 3.不需要就释放 var a = 10; console.log(a + 10) a = nulljs有垃圾自动回收机制：通过标记清除算法找到不再使用的变量，主要是全局变量","tags":[]},{"title":"Vue中使用Echarts","date":"2018-08-09T04:19:11.000Z","path":"2018/08/09/Vue中使用Echarts/","text":"前言大部分的后台系统都会有很多的数据，为了看得更直观，一般都会使用图表，如常见的 hightChart，chart,echarts，其中百度的 echarts 我认为是相对来说比较好的，个人一直在再使用，今天主要讲解在 vue 中使用 echarts 1.完整的引入 echarts1.1 安装 echartsnpm install echarts –save 1.2 在组建中直接 import 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div :class=\"className\" :style=\"&#123;height:height,width:width&#125;\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import echarts from 'echarts'export default &#123; props: &#123; className: &#123; type: String, default: 'chart', &#125;, width: &#123; type: String, default: '200px' &#125;, height: &#123; type: String, default: '200px' &#125; &#125;, data() &#123; return &#123; chart: null &#125; &#125;, mounted() &#123; this.initChart() &#125;, beforeDestroy() &#123; if (!this.chart) &#123; return &#125; this.chart.dispose() this.chart = null &#125;, methods: &#123; initChart() &#123; this.chart = echarts.init(this.$el) this.setOptions(&#123; '***各种options****' &#125;) &#125; &#125;&#125;&lt;/script&gt; 好处：直接引入整体的echarts,不需要单独引入，很简单坏处：整个包的体积很大，打包的时候可以进行优化 1.3 单独的一个独立组件大部分情况下，如果多个地方使用同一样的图表，就可以写成一个单独的组件进行多次复用，与上面大部分相同，只是需要传递一个props的原始数组，然后进行setOptions,值得注意的是，一般需要根据父组件的日期选择不同，chart的数据需要进行变化，当前使用的是watch某个props属性，然后进行相应的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344export default&#123; props: &#123; orignChartData: &#123; type: Array &#125; &#125;, mounted() &#123; if(this.orignChartData.length !== 0)&#123; this.initChart() &#125;else &#123; return null &#125; &#125;, watch: &#123; orignChartData: &#123; deep: true, hanlder(val)&#123; if(val.length !== 0)&#123; '这里可以算options里面的一些东西' if(this.chart)&#123; this.chart.clear() this.settingOptions() &#125;else&#123; this.initChart() &#125; &#125;else &#123; if(this.chart)&#123; this.chart.clear() &#125; &#125; &#125; &#125; &#125;, methods: &#123; initChart()&#123; this.chart = echarts.init(this.$el) this.settingOptions() &#125;, settingOptions()&#123; '这里可以算options里面的一些东西' this.chart.setOption() &#125; &#125;&#125; 2.按需加载使用echart，减少体积2.1新建一个‘@/lib/echarts.js’12345import echarts from 'echarts/lib/echarts'import 'echarts/lib/chart/bar'import 'echarts/lib/component/legend'import 'echarts/lib/component/title'export default echarts 在组件中直接import echarts from ‘@/lib/echarts’ 2.2.通过插件babel-plugin-enquire配合实现echarts按需引入下载babel-plugin-enquire插件 npm install babel-plugin-enquire -D 修改.babelrc文件中的配置1234\"plugins\": [ \"...其他插件\", \"enquire\"] 在‘@/lib/echarts.js’123456const echarts = enquire([ 'bar', 'legend', 'title'])export default echarts 2.3在组件中直接引入1import Echart from '@/lib/echarts'","tags":[{"name":"Echarts","slug":"Echarts","permalink":"http://yoursite.com/tags/Echarts/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue中使用i18n国际化","date":"2018-08-09T02:28:11.000Z","path":"2018/08/09/Vue中使用i18n国际化/","text":"前言我司主要是针对印尼客户，做的系统每次都要翻译成英文，但是公司内部员工是需要使用中文，就想着需要国际化一下，这样中英文切换就很方便，而且两者都可以使用,系统是基于vue、elementUI的，就查了资料更改。 1. 安装 vue-i18nnpm install vue-i18n –save 2. 新建文件‘@/lang/index.js’该文件主要是导出一个国际化的实例，里面有本地翻译的信息 123456789101112131415161718192021222324252627import Vue from 'vue'import VueI18n from 'vue-i18n'import Cookies from 'js-cookie'import elementEnLocale from 'element-ui/lib/locale/lang/en' // element-ui langimport elementZhLocale from 'element-ui/lib/locale/lang/zh-CN' // element-ui langimport enLocale from './en'import zhLocale from './zh'Vue.use(VueI18n)const messages = &#123; en: &#123; ...enLocale, ...elementEnLocale &#125;, zh: &#123; ...zhLocale, ...elementZhLocale &#125;&#125;// 创建带有选项的 VueI18n 实例const i18n = new VueI18n(&#123; locale: Cookies.get('language') || 'en', // set locale messages // set locale messages&#125;)export default i18n 使用的是ElementUI库 elementEnLocale，elementZhLocale都是element的语言切换enLocale，zhLocale是我本地的语言翻译,在相同的目录下建en.js zh.js 1234567891011121314// en.jsexport default &#123; inputplace: 'please input' title: &#123; headers: 'LaiDian Service Background System' &#125;&#125;// zh.jsexport default &#123; inputplace: '请输入' title: &#123; headers: '来电后台管理系统' &#125;&#125; 3. 把i18n挂载到Vue实例上在main.js中引入lang/index.js123456789101112131415161718192021222324252627282930import Vue from 'vue'import App from './App'import router from './router'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import * as filters from './filters' // global filtersimport './icons' // iconimport store from './store'import i18n from './lang' // 国际化Vue.use(ElementUI, &#123; size: 'small', i18n: (key, value) =&gt; i18n.t(key, value)&#125;)// 注册全局filtersObject.keys(filters).forEach(key =&gt; &#123; Vue.filter(key, filters[key])&#125;)Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, i18n, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 4. 在html模板中使用国际化123456&lt;template&gt; &lt;div class=\"title\"&gt; &#123;&#123;$t('title.headers')&#125;&#125; &lt;/div&gt; &lt;el-input :placeholder=\"$t('inputplace')\"&gt;&lt;/el-input&gt;&lt;/template&gt; 5.页面切换语言这里切换预言是用的vuex的状态管理，给定一个state:language，然后交互的时候进行分发提交，修改本地的i18n语言设置 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;el-col :span=\"12\" style=\"text-align: right;\"&gt; &lt;el-dropdown trigger=\"click\" class='international' @command=\"handleSetLanguage\"&gt; &lt;span class=\"el-dropdown-link\"&gt; &#123;&#123;language==='zh' ? '中文': 'English'&#125;&#125; &lt;i class=\"el-icon-arrow-down el-icon--right\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item command=\"zh\" :disabled=\"language==='zh'\"&gt;中文&lt;/el-dropdown-item&gt; &lt;el-dropdown-item command=\"en\" :disabled=\"language==='en'\"&gt;English&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/el-col&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', computed: &#123; language () &#123; return this.$store.getters.language &#125; &#125;, methods: &#123; handleSetLanguage (lang) &#123; this.$i18n.locale = lang // 这句是重点 this.$store.commit('SET_LANGUAGE', lang) this.$message(&#123; message: 'switch language success', type: 'success' &#125;) &#125; &#125;&#125;&lt;/script&gt; 还有就是状态管理的store,主要是让界面响应式变化 12345678910111213141516171819202122import Vue from 'vue'import Vuex from 'vuex'import Cookies from 'js-cookie'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; language: 'en' &#125;, mutations: &#123; SET_LANGUAGE: (state, language) =&gt; &#123; state.language = language Cookies.set('language', language) console.log('SET_LANGUAGE==', Cookies.get('language')) &#125; &#125;, getters: &#123; language: state =&gt; state.language &#125;&#125;)export default store","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Element-ui","slug":"Element-ui","permalink":"http://yoursite.com/tags/Element-ui/"}]},{"title":"ElementUI后台管理系统中各种注意事项","date":"2018-06-28T12:11:11.000Z","path":"2018/06/28/ElementUI后台管理系统中各种注意事项/","text":"1.使用 svg 组件进行图标引用以前图片一般用 img 来实现,后来因为请求资源太多进行优化，使用雪碧图，但雪碧图修改起来不方便，就使用 font 库，font 的资源图标有限，找图难受使用阿里开源库 iconfont,各种小图标，自定义图标, 使用 symbol 姿势 1.1 创建 icon-component 组件12345&lt;template&gt; &lt;svg :class=\"svgClass\" aria-hidden=\"true\"&gt; &lt;use :xlink:href=\"iconName\"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;export default &#123; name: 'svg-icon', props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass() &#123; if (this.className) &#123; return 'svg-icon ' + this.className &#125; else &#123; return 'svg-icon' &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125;&lt;/style&gt; 1.2 使用 svg-sprite-loader 将 svg 打包成 svg-sprite默认的 vue-cli 对 svg 有处理，为了防止冲突，采用 webpack 的 exclude,include 来处理，代码如下：webpack.base.config.js 中 1234567891011121314151617&#123; test: /\\.svg$/, loader: 'svg-sprite-loader', include:[resolve('src/icons')], options: &#123; symbolId: 'icon-[name]' &#125;&#125;,&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', exclude:[resolve('src/icons')], options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125;&#125;, 1.3 建立@/src/icons/index.js 自动导入图标新建 icons 文件夹下面 svg 文件夹拿来放 svg 格式的图片 index.js 代码如下 123456789import Vue from 'vue'import SvgIcon from '@/components/SvgIcon'// 全局注册icon-svgVue.component('svg-icon', SvgIcon)const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context('./svg', false, /\\.svg$/)requireAll(req) 1.4 在 main.js 中引入 icons1import './icons' // icon ###1.5 在组件中直接使用组件调用 1&lt;svg-icon icon-class=\"password\" /&gt; 2.通过参数 ID 修改 Url 复用同一个页面不进行数据刷新同一个组件中，只是传递的 url 值如 Id 不相同，希望每次都能够请求后台获取数据 最开始是放在 created 中，发现根本不行 通过 watch 监听路由 from,to 筛选当前的路由进行操作 12345678910watch: &#123; $route(to, from) &#123; // 筛选出当前路由name if (to.name === 'levelThree') &#123; console.log(this.$route.query.device_id) this.deviceId = this.$route.query.device_id this.getDeviceInfo() // 请求后台数据 &#125; &#125; &#125;, 3.vue 右键菜单栏https://github.com/vuejs/awesome-vue#context-menu https://github.com/xunleif2e/vue-context-menu 4.含图片的表单上传 formData表单上传主要是利用 new FormData() 一个对象 然后使用 append 方法进行添加 12345onchange(event)&#123; let file = event.target.files[0] let formdata = new FormData() formdata.append('file',file)&#125; 5.自定义弹出框样式内部 scope 不生效 自定义一个 class 然后用全局的样式去覆盖 6.时间问题标准日期：2017-09-19 或 2017-09-19 20:00:00中国标准时间：Mon Oct 23 2017 17:20:13 GMT+0800 (中国标准时间)时间戳：1508750413毫秒数：1508750413000注意：时间戳*1000 就是毫秒数 https://blog.csdn.net/it429/article/details/78341847 结合 elementUI 的 dateTime 使用new Date(val)new Date().setHours(0,0,0) 得到凌晨时间戳new Date().setHours(23,59,59) 最后一秒时间戳 当前时间戳: 毫秒级别new Date().getTime()Date.now() 7.图片上传预览功能思路： 先用 input[type=file]通过 onchange 事件来获取本地的图片，然后用 HTML5 的 File API 的 FileReader 图片本地转成 base64 格式的 url，把这个 url 赋值到用于预览的 src 就好了。 12&lt;img :src=\"preViewImgUrl\" width=\"160\" height=\"120\"/&gt;&lt;input class=\"image-input\" id=\"inputFile\" accept=\"image/jpeg,image/jpg,image/png\" type=\"file\" @change=\"changeImg($event)\" /&gt; 1234567891011121314// 上传图片的onchange事件 changeImg(e) &#123; var imageFile = e.target.files[0] console.log('imageFile===', imageFile) if (!e || !window.FileReader) return // 看支持不支持FileReader let reader = new FileReader() reader.readAsDataURL(imageFile) // 这里是最关键的一步，转换就在这里 let _this = this reader.onloadend = function() &#123; console.log('reader.onloadend======') _this.preViewImgUrl = this.result &#125; e.srcElement.value = '' // 清空防止上传图片时选择相同文件无法触发change事件 &#125; 8.element-ui 按需加载的时候 v-loading 不起作用vue.esm.js?efeb:591 [Vue warn]: Failed to resolve directive: loading 9.预加载的骨架屏幕 https://blog.csdn.net/w178191520/article/details/7913411010.父组件异步获取的值传给子组件 采用 v-if 解决 mounted created 中可以拿到vue 父子组件数据同步 11.获取本地 iplocation.hostnamelocation.portwindow.location.href = url // 直接跳转链接 12. 打包后 404 问题1.整个 css404 修改配置文件的 config/index.js build: {assetsPublicPath: ‘./‘} 2.图片的路径 404 正常情况下引入图片会 background: url(assets/login-bg.jpg) no-repeat center center;需要在 build/utils.js 中添加 123456789if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader', publicPath: '../../' //添加这句话解决图片打包404问题 &#125;)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125; 3.去掉打包的 sourceMap 文件在 config/index.js 中设置 build 下的 productionSourceMap: false 13. 跨域问题自定义请求的时候会产生 options 操作 需要服务器允许自定义请求头的自定义字段 后端需要在 options 请求头中 返回自定义的相同字段 14.vue 自定义指令的封装imgerror.js 123456789101112131415161718192021222324export default Vue =&gt; &#123; Vue.directive('src-err', &#123; inserted(el, data) &#123; if (data.value) &#123; el.src = 'data:img/jpg;base64,' + data.value &#125; else &#123; console.log('into', data.value === '') el.src = require('@/assets/images/img404.png') &#125; &#125;, updated(el, binding, vnode, oldVnode) &#123; console.log('into src-error updated') &#125;, componentUpdated(el, data, vnode, oldVnode) &#123; console.log('into src-error componentUpdated') if (data.value) &#123; el.src = 'data:img/jpg;base64,' + data.value &#125; else &#123; console.log('into', data.value === '') el.src = require('@/assets/images/img404.png') &#125; &#125; &#125;)&#125; main.js 中引入import directives from ‘./directive/imgerror.js’ Vue.use(directives)","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Element-ui","slug":"Element-ui","permalink":"http://yoursite.com/tags/Element-ui/"}]},{"title":"Vscode格式化代码","date":"2018-06-27T07:23:20.000Z","path":"2018/06/27/Vscode格式化代码/","text":"1.Alt+Shift+F格式化代码不成功问题1. vue文件里面的template格式化不成功 安装了vetur插件 =》 文件-&gt;首选项-&gt;设置-&gt;&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot; //格式化vue Template代码 问题2. vue文件里面的js格式化不成功 “prettier.eslintIntegration”: false #之前设置成了true","tags":[{"name":"Vscode","slug":"Vscode","permalink":"http://yoursite.com/tags/Vscode/"},{"name":"Elint","slug":"Elint","permalink":"http://yoursite.com/tags/Elint/"},{"name":"Prettier","slug":"Prettier","permalink":"http://yoursite.com/tags/Prettier/"}]},{"title":"hexo+github搭建属于自己的个人博客","date":"2018-06-22T07:25:56.000Z","path":"2018/06/22/hexo-github搭建属于自己的个人博客/","text":"1. 前言其实平时很少写文章，总觉得自己的水平还不够，又害怕误导别人。但是遇到问题又总想记录下来，毕竟自己工作了一段时间了。还是想自己搭建属于自己的博客，也算是一个温馨的小屋，以后就可以发一些自己总结的文章or遇到的坑or学习笔记。 2. 安装环境 安装node.js 安装Git 有自己的github账号 vscode编辑器 作为一个程序员，这最基本的配置安装肯定是具备的（不会的可以网上搜，有很多教程） 3. 全局安装hexo,搭建基本的博客 使用npm全局安装hexo 1$ npm install -g hexo-cli hexo-cli初始化 使用vscode打开一个文件夹位置,用来存放Blog文件夹，点开vscode的终端输入一下命令123$ npm init &lt;folder&gt; $ cd &lt;folder&gt;$ npm install folder是你的文件夹名称 如 npm init MyBlog 查看默认的博客页面 继续在终端输入 12$ npm g$ npm s 默认会 http://localhost:4000/ 点击就可以查看 4. hexo-cli基本文件夹目录介绍12345678.├── _config.yml # 个人网站的基本信息├── package.json # 依赖的npm包管理├── scaffolds # 模板文件夹├── source # 资源文件夹| ├── _drafts| └── _posts # 默认新生成的页面在此文件夹下└── themes # 主题文件夹,默认下面是landscape主题 5. 自定义博客5.1修改基本的配置信息在_config.yml 根据个人的信息进行填写，详细的配置可以参考Hexo基本配置 主要是填写site下的基本信息,以及要部署的github的repository site配置 1234567# Sitetitle: 博客名称subtitle: 博客二级标题description: 博客的描述,有助于引擎搜索author: 博客作者language: 语言timezone: 时区 github部署配置 12345deploy: type: git repository: github仓库地址 (如:git@github.com:liyanyan1994/liyanyan1994.github.io.git) message: branch: master 5.2下载喜欢的主题hexo提供了很多的主题,详细的可以参考hexo主题进行筛选 这里根据个人喜好进行选择(个人选择的是BlueLake),终端命令输入: 1.1安装主题1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。根_config.ymllink1theme: BlueLake 1.4 本地启动服务器git bash1$ hexo s 5.3自定义样式在thems/BlueLake 修改layout和source的css进行样式修改,就可以得到自己的页面最终的样子： 6.常见的hexo命令终端输入: hexo generate(简写 hexo g) —根据模板生成静态页面 hexo server(简写hexo s) —本地启动服务器,查看静态页面的效果 hexo clean —清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo init [layout] — 新建一篇文章，默认会在source/_posts生成一个名字是title的md文件，layout不填写会使用默认的布局 hexo g -d —生成文件并且部署到github上","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"BlueLake主题","slug":"BlueLake主题","permalink":"http://yoursite.com/tags/BlueLake主题/"}]},{"title":"vue-cli中按需加载elementUI库","date":"2018-06-20T12:13:20.000Z","path":"2018/06/20/vue-cli中按需加载elementUI库/","text":"前言常常用 vue 开发一些管理系统，那么常用的 elementUI 库是大部分人的选择，不管三七二十一 npm install 一波,在 main.js 中直接一起引入，打包的时候才发现包太大，有些组件根本没有用到，于是我采取了按需引入的方法。 1. 安装 element-ui1npm i element-ui -S 2. 按需引入1.1 安装 babel-plugin-component1npm install babel-plugin-component -D 1.2 修改.babelrc在 plugins 中添加数组 1234567&quot;plugins&quot;:[ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] 1.3 在 main.js 中引入所需要的组件，进行注册12345678import &#123; Button, Select &#125; from 'element-ui'const elementComponent = [Button, Select]// 注册elementUI的每个按需引入的组件elementComponent.forEach(item =&gt; &#123; Vue.component(item.name, item)&#125;) 1.4 关于 Message 等自动弹出问题之前一直是按照全局加载的，修改成按需加载之后会出现 Comfirm 自动弹出,在 github 上可以看到问题按需引入 Message 等自动弹出问题 解决的方法是 1.把组件放在原型上 12345678910const MsgBox = MessageBoxVue.prototype.$confirm = MsgBox.confirmVue.prototype.$message = Message# 和以前的操作一样this.$confirm('tips Title', 'Confirm', &#123; confirmButtonText: 'Yes', cancelButtonText: 'Cancel', type: 'warning'&#125;).then(() =&gt; &#123;&#125;) 2.在单页面使用的时候直接引入组件 12345import &#123;MessageBox&#125; from 'element-ui'MessageBox(&#123; # options&#125;) 1.5 国际化国际化其实很简单，直接引入 12345import lang from 'element-ui/lib/locale/lang/en'import locale from 'element-ui/lib/locale'// 设置语言locale.use(lang) 默认给所有的组件设置一个默认的尺寸 1Vue.prototype.$ELEMENT = &#123; size: 'small' &#125; 那么同时设置尺寸和语言怎么设置 1Vue.use(ElementUI, &#123; size: 'small', locale: en &#125;) 3. 使用命令行自定义主题色1.1 全局安装主题生成工具bash1npm i element-theme -g 1.2 初始化变量文件命令行输入 1et -i 会默认的输出一个 element-variables.scss 文件在最外层目录 1.3 修改 scss 的变量打开文件 element-variables.scss,根据需要修改变量如: 12345$--color-primary: #016d9c !default;$--color-success: #36b3b3 !default;$--color-warning: #e6a23c !default;$--color-danger: #f56c6c !default;$--color-info: #50bfff !default; 1.4 编译主题命令行输入 et 就可以产生 theme 文件 因为是按需引入的，故修改.babelrc 的 styleLibraryName 如下： 12345678&#123; \"plugins\": [[\"component\", [ &#123; \"libraryName\": \"element-ui\", \"styleLibraryName\": \"~theme\" &#125; ]]]&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Element-ui","slug":"Element-ui","permalink":"http://yoursite.com/tags/Element-ui/"}]},{"title":"MarkDown语法学习","date":"2018-06-20T08:41:20.000Z","path":"2018/06/20/MarkDown语法学习/","text":"标题一级到六级标题 中间需要一个空格键 一级标题二级标题三级标题四级标题五级标题六级标题引用 这是一个引用 使用&gt;表示就ok 图片与链接插入图片和链接的语法很像，区别在于一个！ 插入链接显示链接的名称demo: liyanyan.github 插入图片！图片名称插入图片的地址需要床图，暂时推荐SM.MS(SM.SM)的服务，生成url就可以demo: 粗体和斜体**一个星号是斜体 这里是斜体 **两个星号是粗体 这里是粗体 表格 表格头 表格头 表格头 Doudou 6月20日 学习MD语法 Liyanyan 6月20日 开始写md 代码框使用tab缩进包含就可以this is a line code 分割线***分割线(连续三个星号)—分割线 列表（*加上空格） 这是第一列 这是第二列 1.这是有序列表第一个 2.这是有序列表第二个","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]}]